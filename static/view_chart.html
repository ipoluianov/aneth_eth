<div id="app">
    <h1>%VIEW_NAME%</h1>
    <div style="padding-bottom: 10px;">%VIEW_DESC%</div>
    <!--div style="border: 1px solid #FFFFFF20;">
        <canvas id="myChart_VIEW_INSTANCE" style="width:100%;height: 250px;min-height: 250px;"></canvas>
    </div-->
    <div id="chartContainer"></div>
    <div style="padding-top: 10px;">%VIEW_TEXT%</div>
</div>

<script>
    let chartInstance_VIEW_INSTANCE;
    let items_VIEW_INSTANCE = [];

    function toUnixTime(dateString) {
            const [datePart, timePart] = dateString.split(' ');
            const [year, month, day] = datePart.split('-').map(Number);
            const [hours, minutes, seconds] = timePart.split(':').map(Number);
            //const date = new Date(year, month - 1, day, hours, minutes, seconds);
            const date = this.getUnixTimeInUTCFromParams(year, month, day, hours, minutes, seconds);
            return Math.floor(date);
        }


    function loadData1() {
        console.log("load data")
        loadJson("/d/%VIEW_CODE%").then(data => {
            items_VIEW_INSTANCE = data.TimeChart.Items;
            let xValues = [];
            let yValues = [];

            for (let i in items_VIEW_INSTANCE) {
                let item = items_VIEW_INSTANCE[i];
                xValues.push(item["DTStr"]);
                yValues.push(item["Value"]);
            }

            if (chartInstance_VIEW_INSTANCE) {
                let xData = [];
                let yData = [];
                for (let i in xValues) {
                    let dt = toUnixTime(xValues[i]);
                    const now = new Date();
                    const timezoneOffsetInSeconds = now.getTimezoneOffset() * 60;
                    const unixTimeWithTimezone = Math.floor((dt * 1000 - timezoneOffsetInSeconds * 1000) / 1000);
                    xData.push(unixTimeWithTimezone);
                }
                chartInstance_VIEW_INSTANCE.setData(xData, yValues);
            }
        })
            .catch(error => {
                console.log(error)
            });

    }

    /*function loadData() {
        console.log("load data")
        loadJson("/d/%VIEW_CODE%").then(data => {
            items_VIEW_INSTANCE = data.TimeChart.Items;
            let xValues = [];
            let yValues = [];

            for (let i in items_VIEW_INSTANCE) {
                let item = items_VIEW_INSTANCE[i];
                xValues.push(item["DTStr"]);
                yValues.push(item["Value"]);
            }

            if (chartInstance_VIEW_INSTANCE) {
                chartInstance_VIEW_INSTANCE.data.labels = xValues;
                chartInstance_VIEW_INSTANCE.data.datasets[0].data = yValues;
                chartInstance_VIEW_INSTANCE.update();
                console.log("updated");
            }
        })
            .catch(error => {
                console.log(error)
            });
    }*/

    console.log("mounted")

    /*const ctx_VIEW_INSTANCE = document.getElementById('myChart_VIEW_INSTANCE').getContext('2d');
    chartInstance_VIEW_INSTANCE = new Chart(ctx_VIEW_INSTANCE, {
        type: 'line', // или другой тип графика
        data: {
            labels: [], // примеры меток
            datasets: [{
                label: 'My Dataset',
                data: [], // соответствующие данные
                pointRadius: 0,
                pointHoverRadius: 10,
                tension: 0,
                cubicInterpolationMode: 'monotone',
                borderColor: 'rgba(0,125,255, 1)',
                borderWidth: 2,
            }]
        },
        options: {
            animation: false,
            plugins: { legend: { display: false }, },
            maintainAspectRatio: false,
            scales: {
                x: {
                    type: 'time',
                    time: {
                        parser: 'YYYY-MM-DD HH:mm:ss',
                        tooltipFormat: 'HH:mm',
                        displayFormats: {
                            millisecond: 'YYYY-MM-DD HH:mm:ss',
                            second: 'YYYY-MM-DD HH:mm:ss',
                            minute: 'YYYY-MM-DD HH:mm:ss',
                            hour: 'YYYY-MM-DD HH:mm:ss',
                            day: 'YYYY-MM-DD HH:mm:ss',
                            week: 'YYYY-MM-DD HH:mm:ss',
                            month: 'YYYY-MM-DD HH:mm:ss',
                            quarter: 'YYYY-MM-DD HH:mm:ss',
                            year: 'YYYY-MM-DD HH:mm:ss'
                        }
                    },
                    ticks: {
                        major: {
                            enabled: true // Включаем отображение крупных тиков
                        },
                        source: 'auto',
                        autoSkip: true,
                        autoSkipPadding: 50,
                        maxRotation: 0,
                        sampleSize: 20
                    },
                    grid: {
                        borderDash: [2, 2], // Настройка внешнего вида линий сетки
                        color: function (context) {
                            if (context.tick && context.tick.major) {
                                return '#EEEEEE50'; // Цвет крупных тиков
                            }
                            return '#AAAAAA50'; // Цвет обычных тиков
                        },
                        lineWidth: function (context) {
                            if (context.tick && context.tick.major) {
                                return 1; // Толщина крупных тиков
                            }
                            return 0.5; // Толщина обычных тиков
                        }
                    },
                    title: {
                        display: false,
                        text: 'Time'
                    }
                },
                y: {
                    beginAtZero: false,
                    title: {
                        display: true,
                        text: 'Value'
                    },
                    ticks: {
                        callback: function (value) {
                            return value;
                        }
                    }
                }
            }
        }
    });*/


    class MetricsChart {
        constructor(name, containerId, xData, yData, height, displayMin, displayMax) {
            this.name = name;
            this.containerId = containerId;
            this.container = document.getElementById(containerId);
            this.xData = xData;
            this.yData = yData;
            this.displayMin = displayMin;
            this.displayMax = displayMax;
            this.leftScaleWidth = 80;
            this.bottomScaleheight = 40;
            this.height = height;
            this.yValuesPadding = 0.1;
            this.colorGrid = '#333333';
            this.colorScalesText = '#AAAAAA';
            this.colorSeries = '#00CCFF';
            this.colorBackground = '#111111'
            this.colorDayBorder = '#FFFFFF';
            this.widthDayBorder = 1.5;
            this.widthSeries = 1.5;
            this.fontName = 'Roboto Mono'
            this.canvas = document.createElement('canvas');
            this.context = this.canvas.getContext('2d');
            this.canvas.height = this.height;
            this.container.appendChild(this.canvas);
            this.resize();
            window.addEventListener('resize', () => this.resize());
        }

        resize() {
            this.width = this.container.clientWidth;
            this.canvas.width = this.width;
            this.drawChart();
        }


        setData(xData, yData) {
            console.log("Set Data begin");
            this.xData = xData;
            this.yData = yData;
            this.drawChart();
            console.log("Set Data end");
        }

        getXByValue(xValue) {
            const rangeValues = this.displayMax - this.displayMin;
            const rangePixels = this.width - this.leftScaleWidth
            const pixelsPerValue = rangePixels / rangeValues;
            const result = (xValue - this.displayMin) * pixelsPerValue;
            return this.leftScaleWidth + result;
        }

        getYByValue(yValue) {
            let maxDataValue = Math.max(...this.yData);
            let minDataValue = Math.min(...this.yData);
            const range = maxDataValue - minDataValue;
            minDataValue = minDataValue - range * this.yValuesPadding
            maxDataValue = maxDataValue + range * this.yValuesPadding

            const rangeValues = maxDataValue - minDataValue;
            const rangePixels = this.height - this.bottomScaleheight
            const pixelsPerValue = rangePixels / rangeValues;
            const result = (yValue - minDataValue) * pixelsPerValue;
            return (this.height - this.bottomScaleheight) - result;
        }

        fromUnixTime(unixTime) {
            const date = new Date(unixTime * 1000);
            const year = date.getUTCFullYear();
            const month = String(date.getUTCMonth() + 1).padStart(2, '0');
            const day = String(date.getUTCDate()).padStart(2, '0');
            const hours = String(date.getUTCHours()).padStart(2, '0');
            const minutes = String(date.getUTCMinutes()).padStart(2, '0');
            const seconds = String(date.getUTCSeconds()).padStart(2, '0');
            return `${hours}:${minutes}`;
        }

        fromUnixTimeDate(unixTime) {
            const date = new Date(unixTime * 1000);
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            const hours = String(date.getHours()).padStart(2, '0');
            const minutes = String(date.getMinutes()).padStart(2, '0');
            const seconds = String(date.getSeconds()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        truncateNumberString(input) {
            const isNegative = input.startsWith('-');
            const numberString = isNegative ? input.slice(1) : input;

            if (numberString.length <= 10) {
                return input;
            }

            const [integerPart, fractionalPart] = numberString.split('.');

            if (parseFloat(input) < 1) {
                if (fractionalPart && fractionalPart.length > 10) {
                    return (isNegative ? '-' : '') + `0.${fractionalPart.slice(0, 4)}..${fractionalPart.slice(-2)}`;
                } else if (fractionalPart) {
                    return input.slice(0, 10);
                }
            } else {
                if (integerPart.length > 10) {
                    return (isNegative ? '-' : '') + `${integerPart.slice(0, 4)}..${integerPart.slice(-2)}`;
                } else {
                    return (isNegative ? '-' : '') + `${integerPart}.${fractionalPart.slice(0, 10 - integerPart.length - 1)}`;
                }
            }

            return input.slice(0, 10);
        }

        roundToNearestStep(seconds) {
            const HOUR = 3600;
            const STEPS = [HOUR / 60, HOUR / 30, HOUR / 20, HOUR / 12, HOUR / 6, HOUR / 4, HOUR / 2, HOUR, 2 * HOUR, 3 * HOUR, 6 * HOUR, 12 * HOUR, 24 * HOUR, 48 * HOUR, 72 * HOUR, 96 * HOUR];

            function getNearestStep(value, steps) {
                let nearest = steps[0];
                let minDiff = Math.abs(value - nearest);

                for (let i = 1; i < steps.length; i++) {
                    let diff = Math.abs(value - steps[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearest = steps[i];
                    }
                }
                return nearest;
            }

            return getNearestStep(seconds, STEPS);
        }

        roundToStep(value) {
            const STEPS = [1, 2, 5, 10, 15, 20, 50, 100, 200, 500, 1000]; // Массив шагов

            function getNearestStep(value, steps) {
                let nearest = steps[0];
                let minDiff = Math.abs(value - nearest);

                for (let i = 1; i < steps.length; i++) {
                    let diff = Math.abs(value - steps[i]);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearest = steps[i];
                    }
                }
                return nearest;
            }

            const order = Math.floor(Math.log10(Math.abs(value)));
            const scaledSteps = STEPS.map(step => step * Math.pow(10, order - (step >= 10 ? 1 : 0)));

            const nearestStep = getNearestStep(value, scaledSteps);

            const roundedDown = Math.floor(value / nearestStep) * nearestStep;
            const roundedUp = Math.ceil(value / nearestStep) * nearestStep;

            return roundedUp;
        }

        formatNumbers(numbers) {
            function roundToDecimalPlaces(value, decimalPlaces) {
                const factor = Math.pow(10, decimalPlaces);
                const roundedValue = Math.round(value * factor) / factor;
                return roundedValue.toFixed(decimalPlaces).replace(/\.?0+$/, '');
            }

            function getMinDecimalPlaces(numbers) {
                let minDecimalPlaces = 0;
                for (let i = 0; i < numbers.length - 1; i++) {
                    let diff = Math.abs(numbers[i] - numbers[i + 1]);
                    let decimalPlaces = 0;
                    while (diff < 1 && decimalPlaces < 20) {
                        diff *= 10;
                        decimalPlaces++;
                    }
                    minDecimalPlaces = Math.max(minDecimalPlaces, decimalPlaces);
                }
                return minDecimalPlaces;
            }

            numbers.sort((a, b) => a - b);

            const minDecimalPlaces = getMinDecimalPlaces(numbers);

            const result = numbers.map(number => {
                if (minDecimalPlaces === 0) {
                    return Math.round(number).toString();
                } else {
                    return roundToDecimalPlaces(number, minDecimalPlaces);
                }
            });

            return result;
        }

        clearRectWithBackgroundColor(context, x, y, width, height, backgroundColor) {
            context.clearRect(x, y, width, height);
            context.fillStyle = backgroundColor;
            context.fillRect(x, y, width, height);
        }

        truncateString(input, size) {
            if (input.length > size) {
                return input.slice(0, size - 2) + '..';
            }
            return input;
        }

        drawChart() {
            console.log("");
            console.log("-----------------");
            console.log("drawChart begin");

            const ctx = this.context;
            const width = this.canvas.width;
            const height = this.canvas.height;
            const xData = this.xData;
            const yData = this.yData;

            ctx.save();

            let maxDataValue = Math.max(...yData);
            let minDataValue = Math.min(...yData);
            const range = maxDataValue - minDataValue;
            minDataValue = minDataValue - range * this.yValuesPadding
            maxDataValue = maxDataValue + range * this.yValuesPadding

            ctx.font = '12px ' + this.fontName

            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = 'high';

            this.clearRectWithBackgroundColor(ctx, 0, 0, width, height, this.colorBackground)

            ////////////////////////////////////////////////////
            // Y SCALE /////////////////////////////////////////
            const yLabelHeight = 20;
            const yLabelCount = this.height / yLabelHeight;
            let yScaleStepTemp = (maxDataValue - minDataValue) / yLabelCount;
            let yScaleStep = this.roundToStep(yScaleStepTemp);

            let labels = []
            for (
                let yScaleValue = minDataValue - (minDataValue % yScaleStep);
                yScaleValue < maxDataValue;
                yScaleValue += yScaleStep) {
                labels.push(yScaleValue);
            }

            let labelsStr = this.formatNumbers(labels);


            ctx.lineJoin = 'bevel';
            ctx.beginPath();
            ctx.moveTo(this.leftScaleWidth - 3, 0);
            ctx.lineTo(this.leftScaleWidth - 3, this.height);
            ctx.strokeStyle = this.colorGrid;
            ctx.stroke();

            let index = 0;
            for (
                let yScaleValue = minDataValue - (minDataValue % yScaleStep);
                yScaleValue < maxDataValue;
                yScaleValue += yScaleStep) {
                const y = this.getYByValue(yScaleValue);

                ctx.save();
                ctx.rect(this.leftScaleWidth, 0, this.width - this.leftScaleWidth, this.height - this.bottomScaleheight);
                ctx.clip();

                ctx.beginPath();
                ctx.moveTo(this.leftScaleWidth, y);
                ctx.lineTo(this.width, y);
                ctx.strokeStyle = this.colorGrid;
                ctx.stroke();

                ctx.restore();

                ctx.save();
                ctx.rect(0, 0, this.leftScaleWidth, this.height - this.bottomScaleheight);
                ctx.clip();
                ctx.fillStyle = this.colorScalesText;
                let str = labelsStr[index];
                if (str.length > 10) {
                    ctx.font = '10px ' + this.fontName
                }
                if (str.length > 13) {
                    ctx.font = '8px ' + this.fontName;
                }
                if (str.length > 16) {
                    ctx.font = '6px ' + this.fontName;
                }

                const metrics = ctx.measureText(str);
                const textWidth = metrics.width;
                let strX = this.leftScaleWidth - textWidth - 6;
                ctx.fillText(str, strX, y + 3);
                ctx.restore();

                index++;
            }
            ////////////////////////////////////////////////////

            ////////////////////////////////////////////////////
            // X SCALE /////////////////////////////////////////

            const metricsXScaleLabel = ctx.measureText("00.00.0000");
            const metricsXScaleLabelWidth = metricsXScaleLabel.width;
            const xLabelWidth = metricsXScaleLabelWidth * 1;

            const xLabelCount = (this.width - this.leftScaleWidth) / xLabelWidth;
            let xScaleStep = (this.displayMax - this.displayMin) / xLabelCount;
            xScaleStep = this.roundToNearestStep(xScaleStep);


            ctx.beginPath();
            ctx.moveTo(0, this.height - this.bottomScaleheight + 3);
            ctx.lineTo(this.width, this.height - this.bottomScaleheight + 3);
            ctx.strokeStyle = this.colorGrid;
            ctx.stroke();

            let dates = [];

            ctx.save();
            ctx.rect(this.leftScaleWidth, 0, this.width - this.leftScaleWidth, this.height - this.bottomScaleheight);
            ctx.clip();
            for (
                let xScaleValue = this.displayMin - (this.displayMin % 86400);
                xScaleValue < this.displayMax;
                xScaleValue += 86400) {
                const x = this.getXByValue(xScaleValue);
                ctx.beginPath();
                ctx.moveTo(x, this.height - this.bottomScaleheight);
                ctx.lineTo(x, 0);
                ctx.lineWidth = this.widthDayBorder;
                ctx.strokeStyle = this.colorDayBorder;
                ctx.stroke();
                dates.push(xScaleValue);
            }
            ctx.restore();

            for (
                let xScaleValue = this.displayMin - (this.displayMin % xScaleStep);
                xScaleValue < this.displayMax;
                xScaleValue += xScaleStep) {

                const x = this.getXByValue(xScaleValue);

                ctx.save();
                ctx.rect(this.leftScaleWidth, 0, this.width - this.leftScaleWidth, this.height - this.bottomScaleheight);
                ctx.clip();

                ctx.beginPath();
                ctx.moveTo(x, this.height - this.bottomScaleheight);
                ctx.lineTo(x, 0);
                ctx.strokeStyle = this.colorGrid;
                ctx.stroke();

                ctx.restore();

                const timeLabel = this.fromUnixTime(xScaleValue);
                const dateLabel = this.fromUnixTimeDate(xScaleValue);

                ctx.save();
                ctx.rect(this.leftScaleWidth, this.height - this.bottomScaleheight, this.width - this.leftScaleWidth, this.bottomScaleheight);
                ctx.clip();
                ctx.fillStyle = this.colorScalesText;
                ctx.fillText(timeLabel, x - 18, this.height - this.bottomScaleheight + 15);
                ctx.restore();
            }

            // Dates blocks
            for (let i in dates) {
                const dateLabel = this.fromUnixTimeDate(dates[i]);
                let posXbegin = this.getXByValue(dates[i]);
                let posXend = this.getXByValue(dates[i] + 86400);
                ctx.save();
                ctx.rect(this.leftScaleWidth, this.height - this.bottomScaleheight, this.width - this.leftScaleWidth, this.bottomScaleheight);
                ctx.clip();

                let y = this.height - this.bottomScaleheight + 25;

                ctx.beginPath();
                ctx.moveTo(posXbegin + 2, y);
                ctx.lineTo(posXend - 2, y);
                ctx.strokeStyle = this.colorScalesText;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(posXbegin + 2, y);
                ctx.lineTo(posXbegin + 2, y + 10);
                ctx.strokeStyle = this.colorScalesText;
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(posXend - 2, y);
                ctx.lineTo(posXend - 2, y + 10);
                ctx.strokeStyle = this.colorScalesText;
                ctx.stroke();

                let textPos = posXbegin + (posXend - posXbegin) / 2;
                if (posXbegin < this.leftScaleWidth) {
                    textPos = this.leftScaleWidth + (posXend - this.leftScaleWidth) / 2;
                }
                if (posXend > this.width) {
                    textPos = posXbegin + (this.width - posXbegin) / 2;
                }

                textPos = textPos - 30;

                ctx.fillStyle = this.colorScalesText;
                ctx.fillText(dateLabel, textPos, y + 12);

                ctx.restore();
            }


            ////////////////////////////////////////////////////
            //   DATA  /////////////////////////////////////////
            ctx.save();
            ctx.rect(this.leftScaleWidth, 0, this.width - this.leftScaleWidth, this.height - this.bottomScaleheight);
            ctx.clip();
            ctx.beginPath();
            yData.forEach((value, index) => {
                const x = this.getXByValue(this.xData[index]);
                const y = this.getYByValue(this.yData[index]);
                if (index === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.strokeStyle = this.colorSeries;
            ctx.lineWidth = this.widthSeries;
            ctx.stroke();
            ctx.restore();
            ////////////////////////////////////////////////////

            ////////////////////////////////////////////////////
            //   LOGO  /////////////////////////////////////////
            ctx.fillStyle = this.colorBackground;
            //ctx.beginPath();
            ctx.fillRect(0, 0, this.width, 20);
            ctx.fillStyle = this.colorSeries;
            ctx.font = '16px ' + this.fontName
            ctx.fillText(this.name, 5, 14);
            ctx.font = '16px ' + this.fontName
            ctx.fillText("u00.io - Blockchain analytics", this.width - 290, 14);
            ////////////////////////////////////////////////////
            console.log("drawChart end");

            ctx.restore();
        }


    }

    function getUnixTimeInUTCFromParams(year, month, day, hours, minutes, seconds) {
        const utcTime = Date.UTC(year, month - 1, day, hours, minutes, seconds);
        return Math.floor(utcTime / 1000);
    }

    function toUnixTime(dateString) {
        const [datePart, timePart] = dateString.split(' ');
        const [year, month, day] = datePart.split('-').map(Number);
        const [hours, minutes, seconds] = timePart.split(':').map(Number);
        //const date = new Date(year, month - 1, day, hours, minutes, seconds);
        const date = this.getUnixTimeInUTCFromParams(year, month, day, hours, minutes, seconds);
        return Math.floor(date);
    }

    const now = new Date();
    const unixTimeNow = Math.floor(now.getTime() / 1000);
    const timezoneOffsetInSeconds = now.getTimezoneOffset() * 60;
    const unixTimeWithTimezone = Math.floor((now.getTime() - timezoneOffsetInSeconds * 1000) / 1000);


    chartInstance_VIEW_INSTANCE = new MetricsChart(
        '%VIEW_NAME%',
        'chartContainer',
        [],
        [],
        400,
        unixTimeWithTimezone - 86400,
        unixTimeWithTimezone,
    );


    loadData1();
    setInterval(loadData1, 3000);
</script>